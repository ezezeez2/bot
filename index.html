<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Bird â€” Telegram-ready</title>
<style>
  body{margin:0;background:#70c5ce;display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial}
  canvas{background:#70c5ce;border-radius:8px;border:3px solid rgba(0,0,0,0.08)}
  #start{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:10px 20px;background:#fff;border-radius:10px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.12);font-weight:600}
  #info{position:fixed;left:12px;top:12px;color:#03383e;font-weight:600}
</style>
</head>
<body>
<div id="info">Score: <span id="scoreLbl">0</span></div>
<canvas id="game" width="360" height="640" aria-label="Flappy game"></canvas>
<button id="start">Tap to Start</button>

<script>
/* ---------- CONFIG ---------- */
// Optional fallback server to receive scores (set to null if you don't want fallback)
const SCORE_SERVER_URL = null; // e.g. "https://youruser.pythonanywhere.com/score"
const SCORE_SERVER_TOKEN = "replace_with_same_token_on_server_if_using";

// Game bot short name (for logs only)
const GAME_SHORT_NAME = "aaps";
/* ---------------------------- */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('start');
const scoreLbl = document.getElementById('scoreLbl');

// Telegram detection
let inTelegram = false;
if (typeof TelegramGameProxy !== 'undefined' || (window.Telegram && Telegram.WebApp)) {
  inTelegram = true;
  console.log("Detected Telegram environment.");
} else {
  console.log("Not inside Telegram environment.");
}

// helper: report to your server if Telegram not available
async function reportToServer(payload){
  if (!SCORE_SERVER_URL) return;
  try {
    await fetch(SCORE_SERVER_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-SCORE-TOKEN": SCORE_SERVER_TOKEN
      },
      body: JSON.stringify(payload),
      mode: "cors"
    });
    console.log("Reported score to fallback server:", payload);
  } catch (e) {
    console.warn("Failed reporting score to server:", e);
  }
}

// submit score: prefer Telegram API, otherwise fallback to server
async function submitScoreOnce(finalScore){
  if (submitScoreOnce._sent) return;
  submitScoreOnce._sent = true;

  // Telegram path
  try {
    if (typeof TelegramGameProxy !== 'undefined' && TelegramGameProxy.shareScore) {
      console.log("Submitting score via TelegramGameProxy:", finalScore);
      TelegramGameProxy.shareScore(finalScore);
      // still also optionally report to server (uncomment if you want)
      await reportToServer({event:"gameover",score:finalScore,via:"telegram_proxy",ts:Date.now()});
      return;
    } else if (window.Telegram && Telegram.WebApp && Telegram.WebApp.sendData) {
      console.log("Submitting score via Telegram.WebApp.sendData:", finalScore);
      Telegram.WebApp.sendData(JSON.stringify({score: finalScore}));
      await reportToServer({event:"gameover",score:finalScore,via:"telegram_webapp",ts:Date.now()});
      return;
    } else {
      console.log("Telegram API not available; falling back.");
    }
  } catch (e) {
    console.warn("Telegram score submit error:", e);
  }

  // fallback: report to your server (if configured)
  await reportToServer({event:"gameover",score:finalScore,via:"fallback",ts:Date.now()});
}

/* ---------- Simple Flappy Game (vanilla) ---------- */
let score = 0;
let best = parseInt(localStorage.getItem('flappy_best')||'0',10);
let frames = 0;
let state = { getReady:0, play:1, over:2, current:0 };
let bird = { x:80, y:320, r:14, vy:0 };
let pipes = [];
const gravity = 0.35, flapV = -7.8, pipeSpeed = 2.2, pipeGap = 180, pipeSpacing = 260, groundH = 100;
scoreLbl.innerText = score;

function randRange(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

function resetGame(){
  bird = { x:80, y:340, r:14, vy:0 };
  pipes = [];
  frames = 0;
  score = 0;
  state.current = state.getReady;
  submitScoreOnce._sent = false;
  scoreLbl.innerText = score;
  startBtn.style.display = 'block';
  spawnInitialPipes();
}

function spawnInitialPipes(){
  pipes = [];
  for (let i=0;i<3;i++){
    pipes.push(makePipe(canvas.width + i*pipeSpacing + 40));
  }
}

function makePipe(x){
  const gap = pipeGap;
  const gapY = randRange(80, canvas.height - groundH - 80 - gap);
  return { x, gapY, gap, passed:false };
}

function flap(){
  if (state.current === state.getReady){
    state.current = state.play;
    startBtn.style.display = 'none';
    bird.vy = flapV; // first flap gives lift
    return;
  }
  if (state.current !== state.play) return;
  bird.vy = flapV;
}

function update(){
  if (state.current === state.play){
    // bird physics
    bird.vy += gravity;
    bird.y += bird.vy;
    // pipes movement
    for (const p of pipes) p.x -= pipeSpeed;
    // spawn new pipes
    if (frames % Math.floor(pipeSpacing / pipeSpeed) === 0) {
      pipes.push(makePipe(canvas.width + 40));
    }
    // remove off-screen and scoring
    if (pipes.length && pipes[0].x + 80 < -50) pipes.shift();
    for (const p of pipes){
      if (!p.passed && p.x + 52 < bird.x - bird.r){
        p.passed = true;
        score++;
        scoreLbl.innerText = score;
        if (score > best){ best = score; localStorage.setItem('flappy_best', String(best)); }
      }
      // collision
      if (circleRectCollision(bird.x, bird.y, bird.r, p.x, p.gapY, 52, p.gap) ||
          circleRectCollision(bird.x, bird.y, bird.r, p.x, 0, 52, p.gapY) ){
        state.current = state.over;
        // on first moment of game over, submit score
        submitScoreOnce(score).catch(e=>console.warn(e));
      }
    }
    // ground collision
    if (bird.y + bird.r > canvas.height - groundH){
      bird.y = canvas.height - groundH - bird.r;
      state.current = state.over;
      submitScoreOnce(score).catch(e=>console.warn(e));
    }
  }
  frames++;
}

function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // bg
  ctx.fillStyle = '#9be6ea';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // pipes
  ctx.fillStyle = '#2b8f4a';
  for (const p of pipes){
    ctx.fillRect(p.x, 0, 52, p.gapY);
    ctx.fillRect(p.x, p.gapY + p.gap, 52, canvas.height - groundH - (p.gapY + p.gap));
  }
  // ground
  ctx.fillStyle = '#d49a3c';
  ctx.fillRect(0, canvas.height - groundH, canvas.width, groundH);
  // bird
  ctx.fillStyle = '#ffdd55';
  ctx.beginPath();
  ctx.arc(bird.x, bird.y, bird.r, 0, Math.PI*2);
  ctx.fill();
  // hud
  ctx.fillStyle = '#003';
  ctx.font = '18px Arial';
  ctx.fillText('Best: '+best, canvas.width - 120, 28);

  if (state.current === state.getReady){
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(30,210,canvas.width-60,60);
    ctx.fillStyle = '#03383e';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap / Space to start (first flap will begin)', canvas.width/2, 245);
    ctx.textAlign = 'start';
  } else if (state.current === state.over){
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, canvas.height/2 - 80, canvas.width, 160);
    ctx.fillStyle = '#fff';
    ctx.font = '26px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 20);
    ctx.font = '16px Arial';
    ctx.fillText('Tap to restart', canvas.width/2, canvas.height/2 + 20);
    ctx.textAlign = 'start';
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

// simple circle-rect collision where rect is x,y,w,h (rect origin at top-left)
function circleRectCollision(cx, cy, r, rx, ry, rw, rh){
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx*dx + dy*dy) <= (r*r);
}

// input
canvas.addEventListener('click', ()=> {
  if (state.current === state.getReady) { state.current = state.play; startBtn.style.display='none'; bird.vy = flapV; return; }
  if (state.current === state.play) { flap(); return; }
  if (state.current === state.over) { resetGame(); }
});
startBtn.addEventListener('click', ()=> {
  state.current = state.play; startBtn.style.display = 'none'; bird.vy = flapV;
});
window.addEventListener('keydown', (e)=> {
  if (e.code === 'Space') {
    e.preventDefault();
    if (state.current === state.getReady){ state.current = state.play; startBtn.style.display='none'; bird.vy = flapV; return; }
    if (state.current === state.play){ flap(); }
    if (state.current === state.over){ resetGame(); }
  } else if (e.key === 'r' || e.key === 'R'){
    resetGame();
  }
});

// init
resetGame();
loop();

</script>
</body>
</html>
