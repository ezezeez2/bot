<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy — Telegram-ready</title>
<style>
  :root{--bg1:#9be6ea;--bg2:#70c5ce;--fg:#03383e}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(var(--bg1),var(--bg2))}
  canvas{border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.12);display:block}
  #status{position:fixed;left:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:8px;color:var(--fg);font-size:13px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  #tgDebug{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.75);color:#fff;padding:8px 10px;border-radius:8px;font-size:13px;max-width:320px;box-shadow:0 6px 18px rgba(0,0,0,0.12)}
  #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;border-radius:10px;padding:10px 16px;font-weight:700;cursor:pointer;box-shadow:0 8px 26px rgba(0,0,0,0.18)}
  .footer{position:fixed;right:14px;bottom:14px;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--fg)}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="360" height="640" aria-label="Flappy"></canvas>
</div>

<div id="status">
  <div>Game short name: <strong>Flappy</strong></div>
  <div>Inside Telegram: <strong id="insideVal">?</strong></div>
  <div>Submit mode: <strong id="modeVal">?</strong></div>
  <div>Score: <strong id="scoreVal">0</strong></div>
</div>

<div id="tgDebug">TG debug ready</div>
<button id="startBtn">Tap to Start</button>
<div class="footer">Best: <span id="bestVal">0</span></div>

<script>
/* =========================
   CONFIG
   ========================= */
// Optional fallback server to receive scores when Telegram API is not available.
// If you don't want a fallback server, leave SCORE_SERVER_URL = null.
const SCORE_SERVER_URL = null; // e.g. "https://youruser.pythonanywhere.com/score"
const SCORE_SERVER_TOKEN = "replace_with_server_token_if_using";

/* =========================
   Telegram detection & helpers
   ========================= */
const insideVal = document.getElementById('insideVal');
const modeVal = document.getElementById('modeVal');
const scoreVal = document.getElementById('scoreVal');
const bestVal = document.getElementById('bestVal');
const debugEl = document.getElementById('tgDebug');

let submitMode = 'none';
let inTelegram = false;
try {
  if (typeof TelegramGameProxy !== 'undefined') {
    inTelegram = true;
    submitMode = 'TelegramGameProxy';
  } else if (window.Telegram && Telegram.WebApp) {
    inTelegram = true;
    submitMode = 'Telegram.WebApp';
  } else {
    inTelegram = false;
    submitMode = 'fallback';
  }
} catch (e) {
  inTelegram = false;
  submitMode = 'fallback';
}
insideVal.innerText = inTelegram ? 'YES' : 'NO';
modeVal.innerText = submitMode;

// on-screen logger
function log(msg) {
  console.log(msg);
  debugEl.innerText = String(msg).slice(0, 240);
}

// fallback reporting to your server (if configured)
async function reportToServer(payload) {
  if (!SCORE_SERVER_URL) {
    log('Fallback server not set.');
    return { ok: false, reason: 'no-server' };
  }
  try {
    const r = await fetch(SCORE_SERVER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-SCORE-TOKEN': SCORE_SERVER_TOKEN },
      body: JSON.stringify(payload),
      mode: 'cors'
    });
    const j = await r.json().catch(() => null);
    log('Reported to fallback server: ' + (j ? JSON.stringify(j) : 'ok'));
    return { ok: true, resp: j };
  } catch (e) {
    log('Report failed: ' + e);
    return { ok: false, reason: e.toString() };
  }
}

// Submit score once per game-over
async function submitScoreOnce(finalScore) {
  if (submitScoreOnce._sent) {
    log('Score already sent for this run.');
    return;
  }
  submitScoreOnce._sent = true;

  // prefer TelegramGameProxy
  if (submitMode === 'TelegramGameProxy' && typeof TelegramGameProxy !== 'undefined' && TelegramGameProxy.shareScore) {
    try {
      const value = Math.floor(Number(finalScore) || 0);
      TelegramGameProxy.shareScore(value);
      log('Called TelegramGameProxy.shareScore(' + value + ')');
      if (SCORE_SERVER_URL) await reportToServer({ event: 'gameover', score: value, via: 'telegram_proxy', ts: Date.now() });
      return;
    } catch (e) {
      log('TelegramGameProxy.shareScore error: ' + e);
    }
  }

  // Telegram.WebApp path
  if (submitMode === 'Telegram.WebApp' && window.Telegram && Telegram.WebApp && Telegram.WebApp.sendData) {
    try {
      const value = Math.floor(Number(finalScore) || 0);
      Telegram.WebApp.sendData(JSON.stringify({ score: value }));
      log('Called Telegram.WebApp.sendData(' + value + ')');
      if (SCORE_SERVER_URL) await reportToServer({ event: 'gameover', score: value, via: 'telegram_webapp', ts: Date.now() });
      return;
    } catch (e) {
      log('Telegram.WebApp.sendData error: ' + e);
    }
  }

  // fallback to server only
  const r = await reportToServer({ event: 'gameover', score: finalScore, via: 'fallback', ts: Date.now() });
  if (r.ok) log('Fallback server accepted score: ' + finalScore);
  else log('Fallback result: ' + JSON.stringify(r));
}

/* =========================
   Game code
   ========================= */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');

let W = canvas.width, H = canvas.height;

// Tuned constants
const GRAVITY = 0.35;
const FLAP_SPEED = -8.0;
const BIRD_R = 14;
const PIPE_W = 56;
const PIPE_GAP = 180;
const PIPE_SPACING = 260;
const PIPE_SPEED = 2.2;
const GROUND_H = 100;

// State
let bird = { x: 80, y: H/2, vy: 0, angle: 0 };
let pipes = [];
let frames = 0;
let score = 0;
let best = parseInt(localStorage.getItem('flappy_best') || '0', 10);
let running = false;
let gameOver = false;
let waitingForFirstFlap = false;

scoreVal.innerText = score;
bestVal.innerText = best;

// Utilities
function randRange(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
  const closestX = clamp(cx, rx, rx + rw);
  const closestY = clamp(cy, ry, ry + rh);
  const dx = cx - closestX; const dy = cy - closestY;
  return (dx * dx + dy * dy) <= (r * r);
}

function makePipe(x) {
  const gap = PIPE_GAP;
  const gapY = randRange(80, H - GROUND_H - 80 - gap);
  return { x, gapY, gap, passed: false };
}

function spawnInitialPipes() {
  pipes = [];
  for (let i = 0; i < 3; i++) {
    pipes.push(makePipe(W + i * PIPE_SPACING + 40));
  }
}

function resetGame() {
  bird = { x: 80, y: H / 2, vy: 0, angle: 0 };
  pipes = [];
  frames = 0;
  score = 0;
  running = true;
  gameOver = false;
  waitingForFirstFlap = true;
  submitScoreOnce._sent = false;
  spawnInitialPipes();
  scoreVal.innerText = score;
  startBtn.style.display = 'block';
  log('Game reset — waiting for first flap');
}

function flap() {
  if (!running) { resetGame(); return; }
  if (gameOver) return;
  if (waitingForFirstFlap) {
    waitingForFirstFlap = false;
    bird.vy = FLAP_SPEED;
    bird.angle = -0.6;
    startBtn.style.display = 'none';
    return;
  }
  bird.vy = FLAP_SPEED;
  bird.angle = -0.6;
}

function update() {
  if (!running || gameOver) return;
  if (waitingForFirstFlap) {
    // keep bird still
    bird.vy = 0;
    bird.angle = 0;
    return;
  }

  // physics
  bird.vy += GRAVITY;
  bird.y += bird.vy;
  bird.angle += (bird.vy / 60);
  if (bird.angle > 1.0) bird.angle = 1.0;

  // pipes move
  for (const p of pipes) p.x -= PIPE_SPEED;

  // spawn new pipes
  if (pipes.length === 0 || (pipes[pipes.length - 1].x < W - PIPE_SPACING)) {
    pipes.push(makePipe(W + 40));
  }

  // cleanup off-screen
  if (pipes.length && pipes[0].x + PIPE_W < -40) pipes.shift();

  // scoring & collision
  for (const p of pipes) {
    if (!p.passed && p.x + PIPE_W < bird.x - BIRD_R) {
      p.passed = true;
      score++;
      scoreVal.innerText = score;
      if (score > best) { best = score; localStorage.setItem('flappy_best', String(best)); bestVal.innerText = best; }
      log('Score increment: ' + score);
    }
    // top rect
    if (circleRectCollision(bird.x, bird.y, BIRD_R, p.x, 0, PIPE_W, p.gapY) ||
        circleRectCollision(bird.x, bird.y, BIRD_R, p.x, p.gapY + p.gap, PIPE_W, H - GROUND_H - (p.gapY + p.gap))) {
      // collision -> game over
      if (!gameOver) {
        gameOver = true;
        running = false;
        log('Collision detected — game over. Final score: ' + score);
        submitScoreOnce(score);
      }
    }
  }

  // ground
  if (bird.y + BIRD_R > H - GROUND_H) {
    bird.y = H - GROUND_H - BIRD_R;
    if (!gameOver) {
      gameOver = true;
      running = false;
      log('Hit ground — game over. Final score: ' + score);
      submitScoreOnce(score);
    }
  }

  frames++;
}

function draw() {
  // background
  ctx.clearRect(0, 0, W, H);
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, '#bfeff2'); g.addColorStop(1, '#70c5ce');
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

  // clouds (simple)
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.beginPath(); ctx.ellipse(60 + Math.sin(frames / 40) * 8, 80, 36, 20, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(300 + Math.cos(frames / 50) * 12, 60, 32, 18, 0, 0, Math.PI * 2); ctx.fill();

  // pipes
  for (const p of pipes) {
    ctx.fillStyle = '#2b8f4a';
    ctx.fillRect(p.x, 0, PIPE_W, p.gapY);
    ctx.fillRect(p.x, p.gapY + p.gap, PIPE_W, H - GROUND_H - (p.gapY + p.gap));
    ctx.fillStyle = '#196034';
    ctx.fillRect(p.x, p.gapY - 8, PIPE_W, 8);
    ctx.fillRect(p.x, p.gapY + p.gap, PIPE_W, 8);
  }

  // ground
  ctx.fillStyle = '#d49a3c';
  ctx.fillRect(0, H - GROUND_H, W, GROUND_H);

  // bird
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(bird.angle);
  ctx.fillStyle = '#ffdd55';
  ctx.beginPath(); ctx.ellipse(0, 0, BIRD_R, BIRD_R - 2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ff8a00';
  ctx.beginPath(); ctx.moveTo(BIRD_R + 4, -2); ctx.lineTo(BIRD_R + 14, 2); ctx.lineTo(BIRD_R + 4, 10); ctx.closePath(); ctx.fill();
  ctx.restore();

  // HUD
  ctx.fillStyle = '#03383e';
  ctx.font = '18px system-ui, Arial';
  ctx.fillText('Score: ' + score, 12, 28);
  ctx.fillText('Best: ' + best, W - 110, 28);

  if (!running && !gameOver) {
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(30, 200, W - 60, 60);
    ctx.fillStyle = '#03383e';
    ctx.font = '15px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap / Space to start (first flap will begin)', W / 2, 235);
    ctx.textAlign = 'start';
  }

  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0, H / 2 - 80, W, 160);
    ctx.fillStyle = '#fff'; ctx.font = '28px system-ui, Arial'; ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H / 2 - 20);
    ctx.font = '16px system-ui, Arial'; ctx.fillText('Tap to restart', W / 2, H / 2 + 20);
    ctx.textAlign = 'start';
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

/* ====== Input handling ====== */
canvas.addEventListener('click', () => {
  if (!running) { resetGame(); return; }
  if (gameOver) { resetGame(); return; }
  flap();
});
startBtn.addEventListener('click', () => {
  if (!running) { resetGame(); return; }
  flap();
});
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    if (!running) { resetGame(); return; }
    if (gameOver) { resetGame(); return; }
    flap();
  } else if (e.key === 'r' || e.key === 'R') {
    resetGame();
  }
});

/* ====== Start ====== */
resetGame();
loop();

/* Small UI refresh for status area */
setInterval(() => {
  document.getElementById('insideVal').innerText = inTelegram ? 'YES' : 'NO';
  document.getElementById('modeVal').innerText = submitMode;
  document.getElementById('scoreVal').innerText = score;
  document.getElementById('bestVal').innerText = best;
}, 250);

</script>
</body>
</html>
